来自 Item 5:优先考虑auto而非显式类型声明
https://cntransgroup.github.io/EffectiveModernCppChinese/2.Auto/item5.html

std::function vs. auto vs. Lambda 总结

std::function 的内存与性能开销：
std::function 消耗更多内存且调用速度更慢。主要原因在于其内部的类型擦除机制。当闭包超出其内部缓冲区大小时，std::function 会在堆上动态分配内存。调用时，会通过虚函数或函数指针进行间接调用，这比 auto 的直接调用要慢。

类型擦除的原因与必要性：
类型擦除的核心目的是提供一个统一的、具体的接口来处理异构（不同类型）的可调用对象。这使得您可以在编译时不知道具体类型的情况下，将 Lambda、函数指针和仿函数作为函数参数、类成员或容器元素来使用，实现了运行时的灵活性。

Lambda 与普通函数的类型差异：
Lambda 表达式的类型是编译器生成的独一无二的匿名类，而普通函数的类型是固定的函数指针。这两种类型本质上不同，std::function 正是作为一座桥梁，将它们抽象为一种统一的类型。

Lambda 捕获变量的工作原理及生命周期：
Lambda 通过在其闭包类中创建成员变量来捕获外部变量。
值捕获： 变量的副本被创建，其生命周期由 Lambda 闭包自身管理，是安全的。
引用捕获： Lambda 只保存原始变量的引用。其生命周期由原始变量管理。若 Lambda 的生命周期长于原始变量，将导致危险的悬空引用。

std::shared_ptr 的捕获：
- 值捕获 std::shared_ptr 是安全且推荐的做法。它会复制智能指针，增加引用计数，从而保证 Lambda 闭包存活期间，其所指向的对象也一直有效。
- 引用捕获 std::shared_ptr 存在悬空引用的风险，因为它不增加引用计数，无法保证对象生命周期。

函数参数列表中的 std::function vs. auto：
auto 或模板：追求最高性能和编译时泛型时使用，因为它们提供了零开销的抽象。
std::function：需要类型擦除和统一接口时使用，例如将可调用对象作为回调、异步任务或类成员时。